## 1.VueCLI的使用
* vue create testvuecli3(创建项目文件夹)
```javascript
// 请选择一个配置
? Please pick a preset: (Use arrow keys)
// 默认的配置
> default (babel, eslint)
  // 手动的配置
  Manually select features
```
* 选择手动的配置后
```javascript
// 空格是选举和取消
? Check the features needed for your project: (Press <space> to select, <a> to toggle all, <i> to invert selection)
>(*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 ( ) Router
 ( ) Vuex
 // css预处理
 ( ) CSS Pre-processors
 // ESLInt
 (*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing
```
* 取消掉Linter，其余先什么都不选中（可以选中Router，Vuex，CSS Pre-processors）
```javascript
// 一些的配置是放在package.json中还是单独的配置文件中
? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)
> In dedicated config files
  In package.json
```
* 选择单独的配置之后
```javascript
// 要不要将刚才的配置保存下来，在下一次使用
? Save this as a preset for future projects? (y/N)
```
* 选择yes
```javascript
// 保存的名字
? Save preset as:
```
## 2.Vue CLI3 代码的一些解读
* main.js文件中
```javascript

// 产品的提示信息，没什么太大的作用，当需要看发布的信息的时候可以设置成true
Vue.config.productionTip = false
// 源码中传el的话其实还是执行$mount('#app')方法
new Vue({
  render: h => h(App),
}).$mount('#app')
```
## 3.配置文件
* 配置文件的查看,终端执行以下命令
```javascript
// 本地启动服务进行查看,点击导入选中项目文件夹
// 可以再图像化界面进行管理我们的项目
vue ui
```
* 若想修改Webpack的配置需要在根目录下创建vue.config.js文件进行配置，名字是固定的
## 3.ES6的箭头函数
* 定义函数的一种方式
```javascript
//1.定义函数的一种方式
const app = function(){

}  
// 2.对象字面量的方式
const obj = {
  bbb() {
    
  }
}
// 3.ES6中的箭头函数
const ccc = (参数列表) => {}
```
* 箭头函数的参数和返回值
```javascript
// 1.参数问题
// 1.1 放入两个参数
const sum = (num1, num2) => {
  return num1 + num2
}
// 1.2放入一个参数，括号可以省略
const power = num => {
  return num*num
}
// 2.函数中
// 2.1 代码中有多行代码
const test = () => {
  console.log('111')
  console.log('222')
}
// 2.2 代码中只有一行代码,将结果直接返回
const mul = (num1,num2) => num1*num2
```
* 箭头函数中的this的使用
```javascript
// 箭头函数的this引用的是最近作用域的this
const obj = {
  aaa() {
    setTimeout(function(){
      console.log(this) // window
    })
    setTimeout(() => {
      console.log(this) // obj对象
    })
  }
}
```
## 4..Vue-router的使用
### 4.1 前端渲染和后端渲染
* 后端渲染： 浏览器输入地址 -> 请求发送到服务器 -> 服务器对其进行解析,判断请求什么页面 -> 服务器通过Java（其他技术）+html+css将页面绘制出来并渲染 -> 将页面直接返回给浏览器。
* 后端路由： 后端处理URL和页面之间的映射关系
* 前端渲染： 浏览器中显示的网页中大部分内容，都是由前端写的js代码在浏览器中执行，最终渲染出来的网页
* 单页面富应用：只有一个html页面
### 4.2改变页面的Url页面不进行刷新
```javascript
//第一种，改变url中的hash，默认的方式地址栏会带#
location.hash = 'foo'
// 第二种，H5中的方法(栈)
history.pushState({}, '', 'home')
// 第三种：H5的history模式：replaceState
history.replaceState({}, '', 'home')
// 第四种：结合pushState一起使用
history.go(-1) // 弹出一个界面，显示栈顶元素
history.back()
```
### 4.3安装和使用vue-router
* 安装 npm install --save vue-router
* 在模块化工程中使用它(搭建路由框架的步骤)

  - 第一步：导入路由对象，并调用Vue.use(VueRouter)
  - 第二步：创建路由实例，并且传入路由映射配置
  - 第三步：在Vue实例中挂载创建的路由
  ```javascript
  // 配置路由相关的配置
  import VueRouter from 'vue-router'
  import Vue from 'vue'
  // 1.通过Vue.use（插件），安装插件
  Vue.use(VueRouter)

  // 2.创建VueRouter对象
  const routers = [

  ]

  const router = new VueRouter({
    // 配置路径和组件的映射关系
    routers
  })

  // 3.将router对象传入到Vue实例中
  export default router
  ```
  - 之后再main.js中
  ```javascript
  import router from './router'
  new Vue({
    el: '#app',
    router,
    components: { App },
    template: '<App/>'
  })
  ```
* 使用vue-router的步骤

  - 第一步：创建路由组件
  - 第二步：配置路由映射：组件和路由映射关系
  - 第三步：使用路由：通过router-link（渲染成a标签）和router-view（渲染的位置,作为占位的）
  ```javascript
  router/index.js配置
  // 配置路由相关的配置
  import VueRouter from 'vue-router'
  import Vue from 'vue'
  import Home from '../components/Home'
  import About from '../components/About'
  // 1.通过Vue.use（插件），安装插件
  Vue.use(VueRouter)

  // 2.创建VueRouter对象
  const routes = [
    // 路由的默认值
    {
      path: '/',
      // 重定向
      redirect: '/home'
    },
    {
      path: '/home',
      component: Home
    },
    {
      path: '/about',
      component: About
    }
  ]

  const router = new VueRouter({
    // 配置路径和组件的映射关系
    routes,
    // 使用H5的history模式(地址栏中不会有#号)
    mode: 'history'
  })

  // 3.将router对象传入到Vue实例中
  export default router
  ```
* router-link 的补充
  ```html
  <!-- to属性用来跳转的路径 -->
  <router-link to="/home">首页</router-link>
  <!-- tag 属性可以指定router-link渲染成什么组件,如下渲染成button -->
  <router-link tag="button" to="/home">首页</router-link>
  <!-- replace属性，只能点击按钮返回不能点击浏览器的返回 -->
  <router-link tag="button" to="/home" replace>首页</router-link>
  <!-- active-class 当被点击的时候会自动增加一个样式router-link-class,设置他可以修改样式 -->
  <router-link to="/about" replace active-class="active">关于</router-link>
  <!-- 同意修改活动的样式可以在router下的index.js中设置linkActiveClass:'active' -->
  ```
* 通过代码的方式修改路由
  ```javascript
  this.$router.push('/home')
  ```
* 动态路由
  ```javascript
  router/index.js
  // 动态路由
  {
    path: '/user/:userId',
    component: User
  }
  <router-link :to="'/user/' + userId" replace active-class="active">用户</router-link>
  // 界面通过$route获取动态的路由
  $route.params.userId
  ```
* 打包文件的解析
  
  - app.b584832f53b3e23d1b86.js：当前应用程序开发的所有业务代码
  - manifest.2ae2e69a05c33dfc65f8.js：为打包的代码做底层支撑
  - vendor.c0878b4b1bc21a544ded.js： 第三方的代码
* 路由的懒加载(按需引入，打包的文件更小)
  ```javascript
  // 方式一：结合Vue异步组件和Webpack代码分析
  const Home = resolve => {
    require.ensure(['../commonents/Home.vue'], () => {
      resolve(require('../commonents/Home.vue'))
    })
  }
  // 方式二：AMD写法
  const About = resolve => require(['../commonents/About.vue'], resolve)
  // 方式三： 更简单的Vue异步组件和Webpack代码分析
  const Home = () => import('../commonents/Home.vue')
  ```
* 嵌套路由
  ```javascript
  {
    path: '/home',
    component: Home,
    children: [
      {
        path: 'news',
        component: () => import('../components/HomeNews')
      }
    ]
  },
  ```
* 传递参数的方式
  ```javascript
  // params的类型
  //    配置路由的格式 /router/:id
  //    传递的方式：在path后面跟上对应的值
  //    传递后形成的路径： /router/123, router/abc

  // query的类型
  //    配置路由的格式 /router，也就是普通的配置
  //    传递的方式：对象中使用query的key作为传递的方式
  //    传递后形成的路径： /router？id=123, router?id=abc
  ```
* $router 和 $route的区别
  
  -  $ router路由的组件，$route当前活跃的路由
* 导航守卫
  ```javascript
  // 在路由跳转之前指向的方法(导航的前置钩子函数)
  router.beforeEach((to, from, next) => {
    // 从from 跳到to
    // document.title = to.meta.title
    document.title = to.matched[0].meta.title
    // 默认是指向next的但是我们写方法了会覆盖掉所以要手动执行一下，若不执行路由不会跳转
    next()
  })
  // 导航守卫的补充
  // 补充一： 后置钩子函数，也就是afterEash,不需要主动掉用next()函数
  router.afterEach((to, from) => {
    console.log(22222)
  })
  // 上面使用的导航守卫，被称之为全局守卫
  //  路由独享守卫（官网上看）
  const router = new VueRouter({
    routes: [
      {
        path: '/foo',
        component: Foo,
        beforeEnter: (to, from, next) => {
          // ...
        }
      }
    ]
  })
  //  组件内守卫（官网上看）
  ```
* keep-alive 遇见 vue-router
  
  - keep-alive 是Vue内置的组件，可以使被包含的组件保留状态，避免重新渲染
    
    - include 字符串（Vue组件中的name属性）或正则表达式，只有匹配到的组件会被缓存
    - exclude 字符串（Vue组件中的name属性）或正则表达式，任何匹配的组件都不会被缓存
  - keep-alive 的时候才可以使用activated和deactivated
  - router-view 也是一个组件，如果直接被包在keep-alive里面，所有的路径匹配得到的视图组件就会被缓存