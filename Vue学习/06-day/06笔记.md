## 1.Promise（ES6语法）
* 做什么的？ Promise是异步编程的一种解决方案
  ```javascript
  // 参数 -> 函数(resolve, reject)
  // resolve,reject 本身又是函数
  new Promise((resolve, reject) => {
    // 异步操作
    setTimeout(() => {
      // 调用resolve后会走then函数(成功调用)
      resolve()
    }, 1000)
  }).then(() => {
    console.log('Hello,word')
    return new Promise((resolve, reject) => {
      // 异步操作
      setTimeout(() => {
        // 调用resolve后会走then函数
        // resolve()
        // 错误的时候调用catch方法
        reject('error')
      }, 1000)
    })
  }).then(() => {
    console.log('Hello,vue')
  }).catch((data) => {
    console.log(data)
  })
  // Promise 的第二种写法 then(函数1（resolve时调用）， 函数2（reject时调用）)
  new Promise((resolve,reject) => {
    setTimeout(() => {
      // resolve()
      reject('err')
    }, 1000)
  }).then(() => {
    console.log('调用了resolve')
  }, () => {
    console.log('调用了reject')
  })
  // Promise链式调用的简写，当不需要异步操作时，只要对结果进行处理的话
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('哈哈')
    }, 1000)
  }).then(data => {
    return Promise.resolve(data + '11111')
  }).then(data => {
    console.log(data + '2222')
  }) 
  // 也可以直接return
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('哈哈')
    }, 1000)
  }).then(data => {
    return data + '11111'
  }).then(data => {
    console.log(data + '2222')
  }) 
  ```
## 2. Promise的三种状态（异步操作后会有三种状态）
* pending: 等待状态，比如正在进行网络请求，或者定时器没有到时间
* fulfill: 满足状态，当我们主动回调resolve()时，就处于该状态，并且会回调then()
* reject: 拒绝状态，当我们主动回调reject()时，就处于该状态，并且会回调catch() 
## 3. Promise处理多个请求
```javascript
Promise.all([
  // 两个请求都调用完成之后调用then
  new Promise((resolve, reject) => {
    $ajax({
      url: 'url1',
      success: function(data) {
        resolve(data)
      }
    })
  }),
  new Promise((resolve, reject) => {
    $ajax({
      url: 'url2',
      success: function(data) {
        resolve(data)
      }
    })
  })
// results 是一个数组，也就是两个请求的结果
]).then((results) => {
  result[0]
  result[1]
})
```
## 4. Vuex详解
### 4.1 Vuex是做什么的？
* 状态管理的工具，集中存储管理
* src下创建store文件夹创建index.js文件
```javascript
import Vue from 'vue'
import Vuex from 'vuex'
// 安装插件
Vue.use(Vuex)
// 2.创建对象
const store = new Vuex.Store({
  // 存储状态的
  state: {
    counter: 100
  },
  // 方法
  mutations: {
    increment(state) {
      state.counter++
    },
    decrement(state) {
      state.counter--
    }
  },
  // 进行异步操作（网络请求）
  actions: {
  },
  getters: {
  },
  modules: {
  }
})

// 3.导出
export default store
```
* 页面调用 $store.state.counter
* 修改状态 this.$store.commit('mutations里面定义的方法名')
### 4.2使用步骤的小结：
* 1.提取出一个公共的store对象，用于保存多个组件中的共享状态。
* 2.将store对象放置在Vue对象中，这样可以保证在所有的组件中都可以使用
* 3.在其他组件中使用store对象中所保存的状态即可

  * 通过this.$store.state.属性 的方式来访问状态
  * 通过this.$store.commit('mutation中的方法')来修改状态
* 注意事项
  
  * 通过提交mutation的方式，而非直接改变store.state.count
  * 因为Vuex可以明确的追踪状态的变化，所以不要直接改变store.state.count 
### 4.3Vuex核心概念
* state
```javascript
// State单一状态树：只使用一个Store对象
```
* getters
```javascript
// getters的节本使用： 类似于Vue的计算属性
// $store.getters.powerCount 获取数据
```
* mutation状态更新
```javascript
// 必须是同步的方法，主要的原因是当使用devtools时可以帮助我们捕捉到mutation的快照，异步也采用mutation的haul就不会捕捉到
// Vuex的store状态的更新唯一方式： 提交Mutation
// Mutation主要包含两个部分:
//    字符串的事件类型（type）
//    一个回调函数（handler），该回调函数的第一个参数就是state
// Mutation的定义方式
//  参数被称为是mutation的载荷（Payload）也可以是一个对象
mutations: {
  increment(state,参数) {
    state.counter++
  }
}
// 通过mutation更新
addClick() {
  this.$store.commit('increment',参数)
},
// Mutation的提交风格
//    上面通过commit进行提交是一种普通的方式
//    Vue提供了另外一种风格，是包含type属性的对象
//    payload是一个对象
mutations: {
  increment(state, payload) {
    state.counter+= payload.count
  }
}
// 通过mutation更新
addClick(count) {
  this.$store.commit({
    type: 'increment',
    count: count
  })
},
// mutation常量类型
//    为了避免mutation下的方法过多时造成commit提交时的方法名称出错
//    创建mutation-types.js文件夹定义mutation的常量
export const INCREMENT = 'increment'
//    在界面引用文件需要的常量
import {INCREMENT} from '@/store/mutation-types'
this.$store.commit(INCREMENT)
//    store/index.js也引入常量
import {INCREMENT} from '@/store/mutation-types'
[INCREMENT](state) {
  state.counter++
},
```
* actions
```javascript
// actions类似于mutation， 代替mutation进行异步操作
// 进行异步操作（网络请求）
actions: {
  // context 上下文
  aAddCount(context,count) {
    setTimeout(() => {
      context.commit('addCount', count)
    }, 1000)
  }
}
// 页面调用
addCount(count) {
  // this.$store.commit('addCount', count)
  this.$store.dispatch('aAddCount', count)
}
// 修改成功之后进行回调该怎么办
actions: {
  // context 上下文
  aAddCount(context,payload) {
    setTimeout(() => {
      context.commit('addCount', payload.count)
      console.log(payload.message)
      payload.success()
    }, 1000)
  }
},
addCount(count) {
  // this.$store.commit('addCount', count)
  this.$store.dispatch('aAddCount', {
    count: count,
    message: '我是携带的信息',
    success: () => {
      console.log('里面已经完成')
    }
  })
}
// 更加优雅的方式
bAddCount(context,payload) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      context.commit('addCount', payload)
      console.log('携带的参数',payload)
      resolve('成功回调')
    },1000)
  })
}
addCount(count) {
  // this.$store.commit('addCount', count)
  // this.$store.dispatch('aAddCount', {
  //   count: count,
  //   message: '我是携带的信息',
  //   success: () => {
  //     console.log('里面已经完成')
  //   }
  // })
  this.$store.dispatch('bAddCount', count).then((data) => {
    console.log(data)
  })
}
```
* modules
```javascript
// Vuex允许将store分割成模块(Module),而每个模块拥有自己的state,mutations,actions,getters等
// 模块里state的使用：$store.state.a.name
// 模块里mutations的使用：一样的
```